#!/usr/bin/env bash


cleanup() {
  popd
}


## this runs the last make build you ran in project
if [ -z ${PRJ_ROOT_DIR} ]; then
  echo >&2 "ERROR: Cannot run, missing PRJ_ROOT_DIR environment variables"
  exit 1
else
  pushd  ${PRJ_ROOT_DIR}
  trap cleanup EXIT
fi

if [[ -z $MK_AWS_PROFILE ]]; then
  echo >&2 "ERROR: Must set MK_AWS_PROFILE!"
  exit 1
fi

mkstatefile='/tmp/mk-state'

declare _MK_LAST_CMD

if [ -f "${mkstatefile}" ]; then
  read -r _MK_LAST_CMD <"${mkstatefile}"
else
  _MK_LAST_CMD=""
fi

local_registry='yes'
harbor_tags='no'
docker_tags='no'

# Initialize flags
pynode=false
pulumi=false
awsmgr=false
vice=false
clean=false
rebuild_flask=false
rebuild_node=false
inject=false

build=true
shell=false
save_args=$@

if [[ $1 != -* ]]; then
  command="$1"
  shift
else
  command=''
fi

function show_help() {
  echo """
  -- mk help command--

  mk <COMMAND> <FLAGS>

  COMMANDS
    registry - create/start local registry
    update - Update this repo and submodule
    pynode - Build/run the pynode Docker image
    pulumi - Build/run the pulumi Docker image
    awsmgr - Build/run the awsmgr (base) Docker imge
    vice   - Build/run the main vice Docker image
    clean  - Be careful, this may clear all docker cache.
    all    - Builds pynode, pulumi, awsmgr then vice in that order.
    generate-aws-token  -- Generate temporary token for aws

  FLAGS
    -f/--rebuild-flask  - Builds flask wheel package in dist for awsmgr/vice images
    -n/--rebuild-node   - Builds NextJS tgz package in dist for awsmgr/vice images
    -s/--shell          - load shell for pynode/pulumi/awsmgrvice ie 'mk pynode -s'
    -h/--harbor-tags    - Push to harbor (only works on vice command)
    -k/--docker-tags    - Push to docker
    -i/--inject         - Inject updatd project
  """
}


function update_project() {
  if git status --porcelain | grep -q '^[[:space:]]*[AMD]'; then
    echo "ERROR: Can't update project, you have uncommitted changes."
    git status
    exit 1
  else
      echo "git pull"
      git pull && {
        echo "git submodule update --recursive --remote"
        git submodule update --recursive --remote && {
          echo "Updated submodules, check to make sure they're on main branch and pull"
          exit 0
        } || {
          >&2 echo "ERROR: failed to update submodules"
          exit 1
        }
      } || {
        >&2 echo "ERROR: failed to pull!"
        exit 1
      }

  fi
  popd >/dev/null
  exit 0
}

function load_registry() {
  if docker ps -a --format json | jq -r '.Names' | grep -q 'registry' \
    && docker ps -a --format json | jq -r '.State' | grep -q 'running'; then
    exit 0
  elif docker ps -a --format json | jq -r '.Names' | grep -q 'registry'; then
    docker restart registry
  else
    docker run -d -p 5000:5000 --name registry registry:2
  fi
}

function get_aws_account_id() {
  aws_account_id=$(\
      aws --profile ${MK_AWS_PROFILE} \
      sts get-caller-identity \
        | jq -r .Account \
      || { \
        >&2 echo "ERROR: failed to get AWS Account ID."; \
        exit 1; \
      } \
    )
}

function generate_aws_token() {
  aws_account_id=$(\
      aws --profile ${MK_AWS_PROFILE} \
      sts get-caller-identity \
        | jq -r .Account \
      || { \
        >&2 echo "ERROR: failed to get AWS Account ID."; \
        exit 1; \
      } \
    )
    echo "AWS Account ID: ${aws_account_id}"
    # min 900 seconds or 8 hours max?
    if [[ ! -z ${aws_account_id} ]]; then
      aws_output=$(\
        aws --profile ${MK_AWS_PROFILE} sts assume-role \
        --role-arn "arn:aws:iam::${aws_account_id}:role/AWSManagerRole" \
        --role-session-name "AwsManagerRoleSession" \
        --duration-seconds 900\
      )
      AWS_ACCESS_KEY_ID=$(echo ${aws_output} | jq -r '.Credentials.AccessKeyId')
      AWS_SECRET_ACCESS_KEY=$(echo ${aws_output} | jq -r '.Credentials.SecretAccessKey')
      AWS_SESSION_TOKEN=$(echo ${aws_output} | jq -r '.Credentials.SessionToken')
      AWS_SESSION_TOKEN_EXPIRATION=$(echo ${aws_output} | jq -r '.Credentials.Expiration')
      echo "AWS_SESSION_TOKEN_EXPIRATION=$AWS_SESSION_TOKEN_EXPIRATION"
      if [[ -f ${PRJ_ROOT_DIR}/.env ]]; then
        sed -i "s|^AWS_ACCESS_KEY_ID=.*|AWS_ACCESS_KEY_ID='${AWS_ACCESS_KEY_ID}'|" ${PRJ_ROOT_DIR}/.env
        sed -i "s|^AWS_SECRET_ACCESS_KEY=.*|AWS_SECRET_ACCESS_KEY='${AWS_SECRET_ACCESS_KEY}'|" ${PRJ_ROOT_DIR}/.env
        sed -i "s|^AWS_SESSION_TOKEN=.*|AWS_SESSION_TOKEN='${AWS_SESSION_TOKEN}'|" ${PRJ_ROOT_DIR}/.env
        sed -i "s|^AWS_SESSION_TOKEN_EXPIRATION=.*|AWS_SESSION_TOKEN_EXPIRATION='${AWS_SESSION_TOKEN_EXPIRATION}'|" ${PRJ_ROOT_DIR}/.env
      fi
    fi
}

function parse_long_options() {
  for arg in "$@"; do
    case $arg in
      --rebuild-flask)
        rebuild_flask = true
        ;;
      --rebuild-node)
        rebuild_node = true
        ;;
      --shell)
        valid_commands=("pynode" "pulumi" "awsmgr" "vice")
        found=0
        for cmd in "${valid_commands[@]}"; do
          if [[ "$cmd" == "$command" ]]; then
            found=1
            break
          fi
        done
        if [[ $found -ne 1 ]]; then
            echo >&2 "ERROR: cannot run shell with $command"
            exit 1
          fi
          build=false
          shell=true
        ;;
      --harbor-tags)
        harbor_tags='yes'
        local_registry='no'
        ;;
      --docker-tags)
        docker_tags='yes'
        local_registry='no'
        ;;
      --inject)
        inject=true
        ;;
      *)
        # Ignore unknown options
        ;;
    esac
  done
}

# First, handle long options
parse_long_options "$@"

# Now, handle short options
while getopts "fnshki" opt; do
    case ${opt} in
        f)
            rebuild_flask=true
            ;;
        n)
            rebuild_node=true
            ;;
        s)
          if [[ $command == 'all' ]]; then
            echo >&2 "ERROR: cannot use 'all' with +s"
            exit 1
          fi
          build=false
          shell=true
          ;;
        h)
          # Harbor push
          harbor_tags='yes'
          local_registry='no'
          ;;
        k)
          ## Docker push
          docker_tags='yes'
          local_registry='no'
          ;;
        i)
          inject=true
          ;;
        *)
            # Handle error: unknown option
            exit 1
            ;;
    esac
done

# Loop through arguments and process them
case $command in
  help)
    show_help
    ;;
  registry)
    load_registry
    ;;
  update)
    update_project
    ;;
  pynode)
    pynode=true
    pulumi=false
    awsmgr=false
    vice=false
    ;;
  pulumi)
    pynode=false
    pulumi=true
    awsmgr=false
    vice=false
    ;;
  awsmgr)
    pynode=false
    pulumi=false
    awsmgr=true
    vice=false
    ;;
  vice)
    pynode=false
    pulumi=false
    awsmgr=false
    vice=true
    ;;
  clean)
    clean=true
    ;;
  all)
    pynode=true
    pulumi=true
    awsmgr=true
    vice=true
    ;;
  generate-aws-token)
    generate_aws_token
    ;;
  last)
    if [[ -z ${_MK_LAST_CMD} ]]; then
      echo "No last action!"
    else
      # echo "RUNNING $0 ${_MK_LAST_CMD}"
      $0 ${_MK_LAST_CMD}
    fi
    ;;
  '')
    echo "..."
    ;;
  *)
    # Ignore unknown options / handle error
    exit 1
    ;;
esac

# echo "rebuild_flask = $rebuild_flask"
# echo "rebuild_node = $rebuild_node"
# echo "inject = $inject"
# echo "build = $build"
# echo "shell = $shell"
# echo "local_registry = ${local_registry}"
# echo "harbor_tags = ${harbor_tags}"
# echo "docker_tags = ${docker_tags}"
# echo "pynode = $pynode"
# echo "pulumi = $pulumi"
# echo "awsmgr = $awsmgr"
# echo "vice = $vice"

if [[ ${clean} == true ]]; then
  echo "Cleaning things up"
  make clean
fi

# if no -f or -n flag, but -i (just inject)
if [[ ( ( ${rebuild_flask} == false ) && ( ${rebuild_node} == false ) && ( $inject == true ) ) ]]; then
  echo "Injecting Flask into running docker project"
  make SKIPFLASKBUILD=yes reload-vice-flask-app
  echo "Injecting NextJS into running docker project"
  make SKIPNODEBUILD=yes reload-vice-node-app
fi

if [[ ( ( ${rebuild_flask} == true ) && ( ${build} == true ) ) ]]; then
  echo "Building flask module"
  make build-flask-app
  echo "Building flask module complete"
  if [[ $inject == true ]]; then
    echo "Injecting Flask into running docker project"
    make SKIPFLASKBUILD=yes reload-vice-flask-app
  fi
fi

if [[ ( ( ${rebuild_node} == true ) && ( ${build} == true ) ) ]]; then
  echo "Building yarn module"
  make build-node-app
  echo "Building yarn module complete"
  if [[ $inject == true ]]; then
    echo "Injecting NextJS into running docker project"
    make SKIPNODEBUILD=yes reload-vice-node-app
  fi
fi

if [[ ( ( ${pynode} == true ) && ( ${build} == true ) ) ]]; then
  echo "Building pynode"
  echo "make SKIPFLASKBUILD='yes' SKIPNODEBUILD='yes' LOCALREGISTRY=\"${local_registry}\" build-pynode-image"
  time make SKIPFLASKBUILD='yes' SKIPNODEBUILD='yes' LOCALREGISTRY="${local_registry}" DOCKERREGISTRY="${docker_tags}" build-pynode-image
  echo "pulumi pynode complete"
elif [[ ( ( ${pynode} == true ) && ( ${shell} == true ) ) ]]; then
  make shell-pynode-image
fi

if [[ ( ( ${pulumi} == true ) && ( ${build} == true ) ) ]]; then
  echo "Building pulumi"
  echo "make SKIPFLASKBUILD='yes' SKIPNODEBUILD='yes' LOCALREGISTRY=\"${local_registry}\" build-pulumi-image"
  time make SKIPFLASKBUILD='yes' SKIPNODEBUILD='yes' LOCALREGISTRY="${local_registry}" DOCKERREGISTRY="${docker_tags}" build-pulumi-image
  echo "pulumi build complete"
elif [[ ( ( ${pulumi} == true ) && ( ${shell} == true ) ) ]]; then
  make shell-pulumi-image
fi

if [[ ( ( ${awsmgr} == true ) && ( ${build} == true ) ) ]]; then
  echo "Building awsmgr"
  echo "make SKIPFLASKBUILD='yes' SKIPNODEBUILD='yes'  LOCALREGISTRY=\"${local_registry}\" build-awsmgr-image"
  time make SKIPFLASKBUILD='yes' SKIPNODEBUILD='yes' LOCALREGISTRY="${local_registry}" DOCKERREGISTRY="${docker_tags}" build-awsmgr-image
  echo "awsmgr build complete"
elif [[ ( ( ${awsmgr} == true ) && ( ${shell} == true ) ) ]]; then
  make  shell-awsmgr-image
fi

if [[ ( ( ${vice} == true ) && ( ${build} == true ) ) ]]; then
  echo "Building vice"
  echo "make SKIPFLASKBUILD='yes' SKIPNODEBUILD='yes' LOCALREGISTRY=\"${local_registry}\" build-vice-image"
  time make SKIPFLASKBUILD='yes' SKIPNODEBUILD='yes' LOCALREGISTRY="${local_registry}" DOCKERREGISTRY="${docker_tags}" HARBORREGISTRY="${harbor_tags}" build-vice-image
  echo "vice build complete"
elif [[ ( ( ${vice} == true ) && ( ${shell} == true ) ) ]]; then
  echo "Shelling into vice"
  make shell-vice-image
fi

if [[ $command != 'last' ]]; then
  printf "%s\n" "${save_args}" >"${mkstatefile}"
fi